{
  "version": 3,
  "sources": ["../../@humanfs/core/src/hfs.js", "../../@humanfs/core/src/path.js", "../../@humanfs/core/src/errors.js", "../../@humanfs/core/src/index.js", "../../@humanfs/node/node_modules/@humanwhocodes/retry/dist/retrier.js", "../../@humanfs/node/src/node-hfs.js", "../../@humanfs/node/src/index.js"],
  "sourcesContent": ["/**\r\n * @fileoverview The main file for the humanfs package.\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n/* global URL, TextDecoder, TextEncoder */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Types\r\n//-----------------------------------------------------------------------------\r\n\r\n/** @typedef {import(\"@humanfs/types\").HfsImpl} HfsImpl */\r\n/** @typedef {import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\r\n/** @typedef {import(\"@humanfs/types\").HfsWalkEntry} HfsWalkEntry */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\nconst decoder = new TextDecoder();\r\nconst encoder = new TextEncoder();\r\n\r\n/**\r\n * Error to represent when a method is missing on an impl.\r\n */\r\nexport class NoSuchMethodError extends Error {\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {string} methodName The name of the method that was missing.\r\n\t */\r\n\tconstructor(methodName) {\r\n\t\tsuper(`Method \"${methodName}\" does not exist on impl.`);\r\n\t}\r\n}\r\n\r\n/**\r\n * Error to represent when a method is not supported on an impl. This happens\r\n * when a method on `Hfs` is called with one name and the corresponding method\r\n * on the impl has a different name. (Example: `text()` and `bytes()`.)\r\n */\r\nexport class MethodNotSupportedError extends Error {\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {string} methodName The name of the method that was missing.\r\n\t */\r\n\tconstructor(methodName) {\r\n\t\tsuper(`Method \"${methodName}\" is not supported on this impl.`);\r\n\t}\r\n}\r\n\r\n/**\r\n * Error to represent when an impl is already set.\r\n */\r\nexport class ImplAlreadySetError extends Error {\r\n\t/**\r\n\t * Creates a new instance.\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper(`Implementation already set.`);\r\n\t}\r\n}\r\n\r\n/**\r\n * Asserts that the given path is a valid file path.\r\n * @param {any} fileOrDirPath The path to check.\r\n * @returns {void}\r\n * @throws {TypeError} When the path is not a non-empty string.\r\n */\r\nfunction assertValidFileOrDirPath(fileOrDirPath) {\r\n\tif (\r\n\t\t!fileOrDirPath ||\r\n\t\t(!(fileOrDirPath instanceof URL) && typeof fileOrDirPath !== \"string\")\r\n\t) {\r\n\t\tthrow new TypeError(\"Path must be a non-empty string or URL.\");\r\n\t}\r\n}\r\n\r\n/**\r\n * Asserts that the given file contents are valid.\r\n * @param {any} contents The contents to check.\r\n * @returns {void}\r\n * @throws {TypeError} When the contents are not a string or ArrayBuffer.\r\n */\r\nfunction assertValidFileContents(contents) {\r\n\tif (\r\n\t\ttypeof contents !== \"string\" &&\r\n\t\t!(contents instanceof ArrayBuffer) &&\r\n\t\t!ArrayBuffer.isView(contents)\r\n\t) {\r\n\t\tthrow new TypeError(\r\n\t\t\t\"File contents must be a string, ArrayBuffer, or ArrayBuffer view.\",\r\n\t\t);\r\n\t}\r\n}\r\n\r\n/**\r\n * Converts the given contents to Uint8Array.\r\n * @param {any} contents The data to convert.\r\n * @returns {Uint8Array} The converted Uint8Array.\r\n * @throws {TypeError} When the contents are not a string or ArrayBuffer.\r\n */\r\nfunction toUint8Array(contents) {\r\n\tif (contents instanceof Uint8Array) {\r\n\t\treturn contents;\r\n\t}\r\n\r\n\tif (typeof contents === \"string\") {\r\n\t\treturn encoder.encode(contents);\r\n\t}\r\n\r\n\tif (contents instanceof ArrayBuffer) {\r\n\t\treturn new Uint8Array(contents);\r\n\t}\r\n\r\n\tif (ArrayBuffer.isView(contents)) {\r\n\t\tconst bytes = contents.buffer.slice(\r\n\t\t\tcontents.byteOffset,\r\n\t\t\tcontents.byteOffset + contents.byteLength,\r\n\t\t);\r\n\t\treturn new Uint8Array(bytes);\r\n\t}\r\n\tthrow new TypeError(\r\n\t\t\"Invalid contents type. Expected string or ArrayBuffer.\",\r\n\t);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Exports\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * A class representing a log entry.\r\n */\r\nexport class LogEntry {\r\n\t/**\r\n\t * The type of log entry.\r\n\t * @type {string}\r\n\t */\r\n\ttype;\r\n\r\n\t/**\r\n\t * The data associated with the log entry.\r\n\t * @type {any}\r\n\t */\r\n\tdata;\r\n\r\n\t/**\r\n\t * The time at which the log entry was created.\r\n\t * @type {number}\r\n\t */\r\n\ttimestamp = Date.now();\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {string} type The type of log entry.\r\n\t * @param {any} [data] The data associated with the log entry.\r\n\t */\r\n\tconstructor(type, data) {\r\n\t\tthis.type = type;\r\n\t\tthis.data = data;\r\n\t}\r\n}\r\n\r\n/**\r\n * A class representing a file system utility library.\r\n * @implements {HfsImpl}\r\n */\r\nexport class Hfs {\r\n\t/**\r\n\t * The base implementation for this instance.\r\n\t * @type {HfsImpl}\r\n\t */\r\n\t#baseImpl;\r\n\r\n\t/**\r\n\t * The current implementation for this instance.\r\n\t * @type {HfsImpl}\r\n\t */\r\n\t#impl;\r\n\r\n\t/**\r\n\t * A map of log names to their corresponding entries.\r\n\t * @type {Map<string,Array<LogEntry>>}\r\n\t */\r\n\t#logs = new Map();\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {object} options The options for the instance.\r\n\t * @param {HfsImpl} options.impl The implementation to use.\r\n\t */\r\n\tconstructor({ impl }) {\r\n\t\tthis.#baseImpl = impl;\r\n\t\tthis.#impl = impl;\r\n\t}\r\n\r\n\t/**\r\n\t * Logs an entry onto all currently open logs.\r\n\t * @param {string} methodName The name of the method being called.\r\n\t * @param {...*} args The arguments to the method.\r\n\t * @returns {void}\r\n\t */\r\n\t#log(methodName, ...args) {\r\n\t\tfor (const logs of this.#logs.values()) {\r\n\t\t\tlogs.push(new LogEntry(\"call\", { methodName, args }));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Starts a new log with the given name.\r\n\t * @param {string} name The name of the log to start;\r\n\t * @returns {void}\r\n\t * @throws {Error} When the log already exists.\r\n\t * @throws {TypeError} When the name is not a non-empty string.\r\n\t */\r\n\tlogStart(name) {\r\n\t\tif (!name || typeof name !== \"string\") {\r\n\t\t\tthrow new TypeError(\"Log name must be a non-empty string.\");\r\n\t\t}\r\n\r\n\t\tif (this.#logs.has(name)) {\r\n\t\t\tthrow new Error(`Log \"${name}\" already exists.`);\r\n\t\t}\r\n\r\n\t\tthis.#logs.set(name, []);\r\n\t}\r\n\r\n\t/**\r\n\t * Ends a log with the given name and returns the entries.\r\n\t * @param {string} name The name of the log to end.\r\n\t * @returns {Array<LogEntry>} The entries in the log.\r\n\t * @throws {Error} When the log does not exist.\r\n\t */\r\n\tlogEnd(name) {\r\n\t\tif (this.#logs.has(name)) {\r\n\t\t\tconst logs = this.#logs.get(name);\r\n\t\t\tthis.#logs.delete(name);\r\n\t\t\treturn logs;\r\n\t\t}\r\n\r\n\t\tthrow new Error(`Log \"${name}\" does not exist.`);\r\n\t}\r\n\r\n\t/**\r\n\t * Determines if the current implementation is the base implementation.\r\n\t * @returns {boolean} True if the current implementation is the base implementation.\r\n\t */\r\n\tisBaseImpl() {\r\n\t\treturn this.#impl === this.#baseImpl;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the implementation for this instance.\r\n\t * @param {object} impl The implementation to use.\r\n\t * @returns {void}\r\n\t */\r\n\tsetImpl(impl) {\r\n\t\tthis.#log(\"implSet\", impl);\r\n\r\n\t\tif (this.#impl !== this.#baseImpl) {\r\n\t\t\tthrow new ImplAlreadySetError();\r\n\t\t}\r\n\r\n\t\tthis.#impl = impl;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the implementation for this instance back to its original.\r\n\t * @returns {void}\r\n\t */\r\n\tresetImpl() {\r\n\t\tthis.#log(\"implReset\");\r\n\t\tthis.#impl = this.#baseImpl;\r\n\t}\r\n\r\n\t/**\r\n\t * Asserts that the given method exists on the current implementation.\r\n\t * @param {string} methodName The name of the method to check.\r\n\t * @returns {void}\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t */\r\n\t#assertImplMethod(methodName) {\r\n\t\tif (typeof this.#impl[methodName] !== \"function\") {\r\n\t\t\tthrow new NoSuchMethodError(methodName);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Asserts that the given method exists on the current implementation, and if not,\r\n\t * throws an error with a different method name.\r\n\t * @param {string} methodName The name of the method to check.\r\n\t * @param {string} targetMethodName The name of the method that should be reported\r\n\t *  as an error when methodName does not exist.\r\n\t * @returns {void}\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t */\r\n\t#assertImplMethodAlt(methodName, targetMethodName) {\r\n\t\tif (typeof this.#impl[methodName] !== \"function\") {\r\n\t\t\tthrow new MethodNotSupportedError(targetMethodName);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the given method on the current implementation.\r\n\t * @param {string} methodName The name of the method to call.\r\n\t * @param {...any} args The arguments to the method.\r\n\t * @returns {any} The return value from the method.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t */\r\n\t#callImplMethod(methodName, ...args) {\r\n\t\tthis.#log(methodName, ...args);\r\n\t\tthis.#assertImplMethod(methodName);\r\n\t\treturn this.#impl[methodName](...args);\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the given method on the current implementation and doesn't log the call.\r\n\t * @param {string} methodName The name of the method to call.\r\n\t * @param {...any} args The arguments to the method.\r\n\t * @returns {any} The return value from the method.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t */\r\n\t#callImplMethodWithoutLog(methodName, ...args) {\r\n\t\tthis.#assertImplMethod(methodName);\r\n\t\treturn this.#impl[methodName](...args);\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the given method on the current implementation but logs a different method name.\r\n\t * @param {string} methodName The name of the method to call.\r\n\t * @param {string} targetMethodName The name of the method to log.\r\n\t * @param {...any} args The arguments to the method.\r\n\t * @returns {any} The return value from the method.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t */\r\n\t#callImplMethodAlt(methodName, targetMethodName, ...args) {\r\n\t\tthis.#log(targetMethodName, ...args);\r\n\t\tthis.#assertImplMethodAlt(methodName, targetMethodName);\r\n\t\treturn this.#impl[methodName](...args);\r\n\t}\r\n\r\n\t/**\r\n\t * Reads the given file and returns the contents as text. Assumes UTF-8 encoding.\r\n\t * @param {string|URL} filePath The file to read.\r\n\t * @returns {Promise<string|undefined>} The contents of the file.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the file path is not a non-empty string.\r\n\t */\r\n\tasync text(filePath) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\r\n\t\tconst result = await this.#callImplMethodAlt(\"bytes\", \"text\", filePath);\r\n\t\treturn result ? decoder.decode(result) : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.\r\n\t * @param {string|URL} filePath The file to read.\r\n\t * @returns {Promise<any|undefined>} The contents of the file as JSON.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {SyntaxError} When the file contents are not valid JSON.\r\n\t * @throws {TypeError} When the file path is not a non-empty string.\r\n\t */\r\n\tasync json(filePath) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\r\n\t\tconst result = await this.#callImplMethodAlt(\"bytes\", \"json\", filePath);\r\n\t\treturn result ? JSON.parse(decoder.decode(result)) : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Reads the given file and returns the contents as an ArrayBuffer.\r\n\t * @param {string|URL} filePath The file to read.\r\n\t * @returns {Promise<ArrayBuffer|undefined>} The contents of the file as an ArrayBuffer.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the file path is not a non-empty string.\r\n\t * @deprecated Use bytes() instead.\r\n\t */\r\n\tasync arrayBuffer(filePath) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\r\n\t\tconst result = await this.#callImplMethodAlt(\r\n\t\t\t\"bytes\",\r\n\t\t\t\"arrayBuffer\",\r\n\t\t\tfilePath,\r\n\t\t);\r\n\t\treturn result?.buffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Reads the given file and returns the contents as an Uint8Array.\r\n\t * @param {string|URL} filePath The file to read.\r\n\t * @returns {Promise<Uint8Array|undefined>} The contents of the file as an Uint8Array.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the file path is not a non-empty string.\r\n\t */\r\n\tasync bytes(filePath) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\t\treturn this.#callImplMethod(\"bytes\", filePath);\r\n\t}\r\n\r\n\t/**\r\n\t * Writes the given data to the given file. Creates any necessary directories along the way.\r\n\t * If the data is a string, UTF-8 encoding is used.\r\n\t * @param {string|URL} filePath The file to write.\r\n\t * @param {string|ArrayBuffer|ArrayBufferView} contents The data to write.\r\n\t * @returns {Promise<void>} A promise that resolves when the file is written.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the file path is not a non-empty string.\r\n\t */\r\n\tasync write(filePath, contents) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\t\tassertValidFileContents(contents);\r\n\t\tthis.#log(\"write\", filePath, contents);\r\n\r\n\t\tlet value = toUint8Array(contents);\r\n\t\treturn this.#callImplMethodWithoutLog(\"write\", filePath, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Appends the given data to the given file. Creates any necessary directories along the way.\r\n\t * If the data is a string, UTF-8 encoding is used.\r\n\t * @param {string|URL} filePath The file to append to.\r\n\t * @param {string|ArrayBuffer|ArrayBufferView} contents The data to append.\r\n\t * @returns {Promise<void>} A promise that resolves when the file is appended to.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the file path is not a non-empty string.\r\n\t * @throws {TypeError} When the file contents are not a string or ArrayBuffer.\r\n\t * @throws {Error} When the file cannot be appended to.\r\n\t */\r\n\tasync append(filePath, contents) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\t\tassertValidFileContents(contents);\r\n\t\tthis.#log(\"append\", filePath, contents);\r\n\r\n\t\tlet value = toUint8Array(contents);\r\n\t\treturn this.#callImplMethodWithoutLog(\"append\", filePath, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Determines if the given file exists.\r\n\t * @param {string|URL} filePath The file to check.\r\n\t * @returns {Promise<boolean>} True if the file exists.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the file path is not a non-empty string.\r\n\t */\r\n\tasync isFile(filePath) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\t\treturn this.#callImplMethod(\"isFile\", filePath);\r\n\t}\r\n\r\n\t/**\r\n\t * Determines if the given directory exists.\r\n\t * @param {string|URL} dirPath The directory to check.\r\n\t * @returns {Promise<boolean>} True if the directory exists.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the directory path is not a non-empty string.\r\n\t */\r\n\tasync isDirectory(dirPath) {\r\n\t\tassertValidFileOrDirPath(dirPath);\r\n\t\treturn this.#callImplMethod(\"isDirectory\", dirPath);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates the given directory.\r\n\t * @param {string|URL} dirPath The directory to create.\r\n\t * @returns {Promise<void>} A promise that resolves when the directory is created.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the directory path is not a non-empty string.\r\n\t */\r\n\tasync createDirectory(dirPath) {\r\n\t\tassertValidFileOrDirPath(dirPath);\r\n\t\treturn this.#callImplMethod(\"createDirectory\", dirPath);\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes the given file or empty directory.\r\n\t * @param {string|URL} filePath The file to delete.\r\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\r\n\t *   directory is deleted, true if the file or directory is deleted, false\r\n\t *   if the file or directory does not exist.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the file path is not a non-empty string.\r\n\t */\r\n\tasync delete(filePath) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\t\treturn this.#callImplMethod(\"delete\", filePath);\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes the given file or directory recursively.\r\n\t * @param {string|URL} dirPath The directory to delete.\r\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\r\n\t *   directory is deleted, true if the file or directory is deleted, false\r\n\t *   if the file or directory does not exist.\r\n\t * @throws {NoSuchMethodError} When the method does not exist on the current implementation.\r\n\t * @throws {TypeError} When the directory path is not a non-empty string.\r\n\t */\r\n\tasync deleteAll(dirPath) {\r\n\t\tassertValidFileOrDirPath(dirPath);\r\n\t\treturn this.#callImplMethod(\"deleteAll\", dirPath);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of directory entries for the given path.\r\n\t * @param {string|URL} dirPath The path to the directory to read.\r\n\t * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\r\n\t *   directory entries.\r\n\t * @throws {TypeError} If the directory path is not a string or URL.\r\n\t * @throws {Error} If the directory cannot be read.\r\n\t */\r\n\tasync *list(dirPath) {\r\n\t\tassertValidFileOrDirPath(dirPath);\r\n\t\tyield* await this.#callImplMethod(\"list\", dirPath);\r\n\t}\r\n\r\n\t/**\r\n\t * Walks a directory using a depth-first traversal and returns the entries\r\n\t * from the traversal.\r\n\t * @param {string|URL} dirPath The path to the directory to walk.\r\n\t * @param {Object} [options] The options for the walk.\r\n\t * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.directoryFilter] A filter function to determine\r\n\t * \tif a directory's entries should be included in the walk.\r\n\t * @param {(entry:HfsWalkEntry) => Promise<boolean>|boolean} [options.entryFilter] A filter function to determine if\r\n\t * \tan entry should be included in the walk.\r\n\t * @returns {AsyncIterable<HfsWalkEntry>} A promise that resolves with the\r\n\t * \tdirectory entries.\r\n\t * @throws {TypeError} If the directory path is not a string or URL.\r\n\t * @throws {Error} If the directory cannot be read.\r\n\t */\r\n\tasync *walk(\r\n\t\tdirPath,\r\n\t\t{ directoryFilter = () => true, entryFilter = () => true } = {},\r\n\t) {\r\n\t\tassertValidFileOrDirPath(dirPath);\r\n\t\tthis.#log(\"walk\", dirPath, { directoryFilter, entryFilter });\r\n\r\n\t\t// inner function for recursion without additional logging\r\n\t\tconst walk = async function* (\r\n\t\t\tdirPath,\r\n\t\t\t{ directoryFilter, entryFilter, parentPath = \"\", depth = 1 },\r\n\t\t) {\r\n\t\t\tlet dirEntries;\r\n\r\n\t\t\ttry {\r\n\t\t\t\tdirEntries = await this.#callImplMethodWithoutLog(\r\n\t\t\t\t\t\"list\",\r\n\t\t\t\t\tdirPath,\r\n\t\t\t\t);\r\n\t\t\t} catch (error) {\r\n\t\t\t\t// if the directory does not exist then return an empty array\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// otherwise, rethrow the error\r\n\t\t\t\tthrow error;\r\n\t\t\t}\r\n\r\n\t\t\tfor await (const listEntry of dirEntries) {\r\n\t\t\t\tconst walkEntry = {\r\n\t\t\t\t\tpath: listEntry.name,\r\n\t\t\t\t\tdepth,\r\n\t\t\t\t\t...listEntry,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (parentPath) {\r\n\t\t\t\t\twalkEntry.path = `${parentPath}/${walkEntry.path}`;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// first emit the entry but only if the entry filter returns true\r\n\t\t\t\tlet shouldEmitEntry = entryFilter(walkEntry);\r\n\t\t\t\tif (shouldEmitEntry.then) {\r\n\t\t\t\t\tshouldEmitEntry = await shouldEmitEntry;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (shouldEmitEntry) {\r\n\t\t\t\t\tyield walkEntry;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if it's a directory then yield the entry and walk the directory\r\n\t\t\t\tif (listEntry.isDirectory) {\r\n\t\t\t\t\t// if the directory filter returns false, skip the directory\r\n\t\t\t\t\tlet shouldWalkDirectory = directoryFilter(walkEntry);\r\n\t\t\t\t\tif (shouldWalkDirectory.then) {\r\n\t\t\t\t\t\tshouldWalkDirectory = await shouldWalkDirectory;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!shouldWalkDirectory) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// make sure there's a trailing slash on the directory path before appending\r\n\t\t\t\t\tconst directoryPath =\r\n\t\t\t\t\t\tdirPath instanceof URL\r\n\t\t\t\t\t\t\t? new URL(\r\n\t\t\t\t\t\t\t\t\tlistEntry.name,\r\n\t\t\t\t\t\t\t\t\tdirPath.href.endsWith(\"/\")\r\n\t\t\t\t\t\t\t\t\t\t? dirPath.href\r\n\t\t\t\t\t\t\t\t\t\t: `${dirPath.href}/`,\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t: `${dirPath.endsWith(\"/\") ? dirPath : `${dirPath}/`}${listEntry.name}`;\r\n\r\n\t\t\t\t\tyield* walk(directoryPath, {\r\n\t\t\t\t\t\tdirectoryFilter,\r\n\t\t\t\t\t\tentryFilter,\r\n\t\t\t\t\t\tparentPath: walkEntry.path,\r\n\t\t\t\t\t\tdepth: depth + 1,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}.bind(this);\r\n\r\n\t\tyield* walk(dirPath, { directoryFilter, entryFilter });\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the size of the given file.\r\n\t * @param {string|URL} filePath The path to the file to read.\r\n\t * @returns {Promise<number>} A promise that resolves with the size of the file.\r\n\t * @throws {TypeError} If the file path is not a string or URL.\r\n\t * @throws {Error} If the file cannot be read.\r\n\t */\r\n\tasync size(filePath) {\r\n\t\tassertValidFileOrDirPath(filePath);\r\n\t\treturn this.#callImplMethod(\"size\", filePath);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the last modified timestamp of the given file or directory.\r\n\t * @param {string|URL} fileOrDirPath The path to the file or directory.\r\n\t * @returns {Promise<Date|undefined>} A promise that resolves with the last modified date\r\n\t *  or undefined if the file or directory does not exist.\r\n\t * @throws {TypeError} If the path is not a string or URL.\r\n\t */\r\n\tasync lastModified(fileOrDirPath) {\r\n\t\tassertValidFileOrDirPath(fileOrDirPath);\r\n\t\treturn this.#callImplMethod(\"lastModified\", fileOrDirPath);\r\n\t}\r\n\r\n\t/**\r\n\t * Copys a file from one location to another.\r\n\t * @param {string|URL} source The path to the file to copy.\r\n\t * @param {string|URL} destination The path to the new file.\r\n\t * @returns {Promise<void>} A promise that resolves when the file is copied.\r\n\t * @throws {TypeError} If the file path is not a string or URL.\r\n\t * @throws {Error} If the file cannot be copied.\r\n\t */\r\n\tasync copy(source, destination) {\r\n\t\tassertValidFileOrDirPath(source);\r\n\t\tassertValidFileOrDirPath(destination);\r\n\t\treturn this.#callImplMethod(\"copy\", source, destination);\r\n\t}\r\n\r\n\t/**\r\n\t * Copies a file or directory from one location to another.\r\n\t * @param {string|URL} source The path to the file or directory to copy.\r\n\t * @param {string|URL} destination The path to copy the file or directory to.\r\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\r\n\t * copied.\r\n\t * @throws {TypeError} If the directory path is not a string or URL.\r\n\t * @throws {Error} If the directory cannot be copied.\r\n\t */\r\n\tasync copyAll(source, destination) {\r\n\t\tassertValidFileOrDirPath(source);\r\n\t\tassertValidFileOrDirPath(destination);\r\n\t\treturn this.#callImplMethod(\"copyAll\", source, destination);\r\n\t}\r\n\r\n\t/**\r\n\t * Moves a file from the source path to the destination path.\r\n\t * @param {string|URL} source The location of the file to move.\r\n\t * @param {string|URL} destination The destination of the file to move.\r\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\r\n\t * @throws {TypeError} If the file or directory paths are not strings.\r\n\t * @throws {Error} If the file or directory cannot be moved.\r\n\t */\r\n\tasync move(source, destination) {\r\n\t\tassertValidFileOrDirPath(source);\r\n\t\tassertValidFileOrDirPath(destination);\r\n\t\treturn this.#callImplMethod(\"move\", source, destination);\r\n\t}\r\n\r\n\t/**\r\n\t * Moves a file or directory from one location to another.\r\n\t * @param {string|URL} source The path to the file or directory to move.\r\n\t * @param {string|URL} destination The path to move the file or directory to.\r\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\r\n\t * moved.\r\n\t * @throws {TypeError} If the source is not a string or URL.\r\n\t * @throws {TypeError} If the destination is not a string or URL.\r\n\t * @throws {Error} If the file or directory cannot be moved.\r\n\t */\r\n\tasync moveAll(source, destination) {\r\n\t\tassertValidFileOrDirPath(source);\r\n\t\tassertValidFileOrDirPath(destination);\r\n\t\treturn this.#callImplMethod(\"moveAll\", source, destination);\r\n\t}\r\n}\r\n", "/**\r\n * @fileoverview The Path class.\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n/* globals URL */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Types\r\n//-----------------------------------------------------------------------------\r\n\r\n/** @typedef{import(\"@humanfs/types\").HfsImpl} HfsImpl */\r\n/** @typedef{import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Normalizes a path to use forward slashes.\r\n * @param {string} filePath The path to normalize.\r\n * @returns {string} The normalized path.\r\n */\r\nfunction normalizePath(filePath) {\r\n\tlet startIndex = 0;\r\n\tlet endIndex = filePath.length;\r\n\r\n\tif (/[a-z]:\\//i.test(filePath)) {\r\n\t\tstartIndex = 3;\r\n\t}\r\n\r\n\tif (filePath.startsWith(\"./\")) {\r\n\t\tstartIndex = 2;\r\n\t}\r\n\r\n\tif (filePath.startsWith(\"/\")) {\r\n\t\tstartIndex = 1;\r\n\t}\r\n\r\n\tif (filePath.endsWith(\"/\")) {\r\n\t\tendIndex = filePath.length - 1;\r\n\t}\r\n\r\n\treturn filePath.slice(startIndex, endIndex).replace(/\\\\/g, \"/\");\r\n}\r\n\r\n/**\r\n * Asserts that the given name is a non-empty string, no equal to \".\" or \"..\",\r\n * and does not contain a forward slash or backslash.\r\n * @param {string} name The name to check.\r\n * @returns {void}\r\n * @throws {TypeError} When name is not valid.\r\n */\r\nfunction assertValidName(name) {\r\n\tif (typeof name !== \"string\") {\r\n\t\tthrow new TypeError(\"name must be a string\");\r\n\t}\r\n\r\n\tif (!name) {\r\n\t\tthrow new TypeError(\"name cannot be empty\");\r\n\t}\r\n\r\n\tif (name === \".\") {\r\n\t\tthrow new TypeError(`name cannot be \".\"`);\r\n\t}\r\n\r\n\tif (name === \"..\") {\r\n\t\tthrow new TypeError(`name cannot be \"..\"`);\r\n\t}\r\n\r\n\tif (name.includes(\"/\") || name.includes(\"\\\\\")) {\r\n\t\tthrow new TypeError(\r\n\t\t\t`name cannot contain a slash or backslash: \"${name}\"`,\r\n\t\t);\r\n\t}\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Exports\r\n//-----------------------------------------------------------------------------\r\n\r\nexport class Path {\r\n\t/**\r\n\t * The steps in the path.\r\n\t * @type {Array<string>}\r\n\t */\r\n\t#steps;\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {Iterable<string>} [steps] The steps to use for the path.\r\n\t * @throws {TypeError} When steps is not iterable.\r\n\t */\r\n\tconstructor(steps = []) {\r\n\t\tif (typeof steps[Symbol.iterator] !== \"function\") {\r\n\t\t\tthrow new TypeError(\"steps must be iterable\");\r\n\t\t}\r\n\r\n\t\tthis.#steps = [...steps];\r\n\t\tthis.#steps.forEach(assertValidName);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds steps to the end of the path.\r\n\t * @param  {...string} steps The steps to add to the path.\r\n\t * @returns {void}\r\n\t */\r\n\tpush(...steps) {\r\n\t\tsteps.forEach(assertValidName);\r\n\t\tthis.#steps.push(...steps);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the last step from the path.\r\n\t * @returns {string} The last step in the path.\r\n\t */\r\n\tpop() {\r\n\t\treturn this.#steps.pop();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an iterator for steps in the path.\r\n\t * @returns {IterableIterator<string>} An iterator for the steps in the path.\r\n\t */\r\n\tsteps() {\r\n\t\treturn this.#steps.values();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an iterator for the steps in the path.\r\n\t * @returns {IterableIterator<string>} An iterator for the steps in the path.\r\n\t */\r\n\t[Symbol.iterator]() {\r\n\t\treturn this.steps();\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves the name (the last step) of the path.\r\n\t * @type {string}\r\n\t */\r\n\tget name() {\r\n\t\treturn this.#steps[this.#steps.length - 1];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the name (the last step) of the path.\r\n\t * @type {string}\r\n\t */\r\n\tset name(value) {\r\n\t\tassertValidName(value);\r\n\t\tthis.#steps[this.#steps.length - 1] = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves the size of the path.\r\n\t * @type {number}\r\n\t */\r\n\tget size() {\r\n\t\treturn this.#steps.length;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the path as a string.\r\n\t * @returns {string} The path as a string.\r\n\t */\r\n\ttoString() {\r\n\t\treturn this.#steps.join(\"/\");\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new path based on the argument type. If the argument is a string,\r\n\t * it is assumed to be a file or directory path and is converted to a Path\r\n\t * instance. If the argument is a URL, it is assumed to be a file URL and is\r\n\t * converted to a Path instance. If the argument is a Path instance, it is\r\n\t * copied into a new Path instance. If the argument is an array, it is assumed\r\n\t * to be the steps of a path and is used to create a new Path instance.\r\n\t * @param {string|URL|Path|Array<string>} pathish The value to convert to a Path instance.\r\n\t * @returns {Path} A new Path instance.\r\n\t * @throws {TypeError} When pathish is not a string, URL, Path, or Array.\r\n\t * @throws {TypeError} When pathish is a string and is empty.\r\n\t */\r\n\tstatic from(pathish) {\r\n\t\tif (typeof pathish === \"string\") {\r\n\t\t\tif (!pathish) {\r\n\t\t\t\tthrow new TypeError(\"argument cannot be empty\");\r\n\t\t\t}\r\n\r\n\t\t\treturn Path.fromString(pathish);\r\n\t\t}\r\n\r\n\t\tif (pathish instanceof URL) {\r\n\t\t\treturn Path.fromURL(pathish);\r\n\t\t}\r\n\r\n\t\tif (pathish instanceof Path || Array.isArray(pathish)) {\r\n\t\t\treturn new Path(pathish);\r\n\t\t}\r\n\r\n\t\tthrow new TypeError(\"argument must be a string, URL, Path, or Array\");\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new Path instance from a string.\r\n\t * @param {string} fileOrDirPath The file or directory path to convert.\r\n\t * @returns {Path} A new Path instance.\r\n\t * @deprecated Use Path.from() instead.\r\n\t */\r\n\tstatic fromString(fileOrDirPath) {\r\n\t\treturn new Path(normalizePath(fileOrDirPath).split(\"/\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new Path instance from a URL.\r\n\t * @param {URL} url The URL to convert.\r\n\t * @returns {Path} A new Path instance.\r\n\t * @throws {TypeError} When url is not a URL instance.\r\n\t * @throws {TypeError} When url.pathname is empty.\r\n\t * @throws {TypeError} When url.protocol is not \"file:\".\r\n\t * @deprecated Use Path.from() instead.\r\n\t */\r\n\tstatic fromURL(url) {\r\n\t\tif (!(url instanceof URL)) {\r\n\t\t\tthrow new TypeError(\"url must be a URL instance\");\r\n\t\t}\r\n\r\n\t\tif (!url.pathname || url.pathname === \"/\") {\r\n\t\t\tthrow new TypeError(\"url.pathname cannot be empty\");\r\n\t\t}\r\n\r\n\t\tif (url.protocol !== \"file:\") {\r\n\t\t\tthrow new TypeError(`url.protocol must be \"file:\"`);\r\n\t\t}\r\n\r\n\t\t// Remove leading slash in pathname\r\n\t\treturn new Path(normalizePath(url.pathname.slice(1)).split(\"/\"));\r\n\t}\r\n}\r\n", "/**\r\n * @fileoverview Common error classes\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n/**\r\n * Error thrown when a file or directory is not found.\r\n */\r\nexport class NotFoundError extends Error {\r\n\t/**\r\n\t * Name of the error class.\r\n\t * @type {string}\r\n\t */\r\n\tname = \"NotFoundError\";\r\n\r\n\t/**\r\n\t * Error code.\r\n\t * @type {string}\r\n\t */\r\n\tcode = \"ENOENT\";\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {string} message The error message.\r\n\t */\r\n\tconstructor(message) {\r\n\t\tsuper(`ENOENT: No such file or directory, ${message}`);\r\n\t}\r\n}\r\n\r\n/**\r\n * Error thrown when an operation is not permitted.\r\n */\r\nexport class PermissionError extends Error {\r\n\t/**\r\n\t * Name of the error class.\r\n\t * @type {string}\r\n\t */\r\n\tname = \"PermissionError\";\r\n\r\n\t/**\r\n\t * Error code.\r\n\t * @type {string}\r\n\t */\r\n\tcode = \"EPERM\";\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {string} message The error message.\r\n\t */\r\n\tconstructor(message) {\r\n\t\tsuper(`EPERM: Operation not permitted, ${message}`);\r\n\t}\r\n}\r\n\r\n/**\r\n * Error thrown when an operation is not allowed on a directory.\r\n */\r\n\r\nexport class DirectoryError extends Error {\r\n\t/**\r\n\t * Name of the error class.\r\n\t * @type {string}\r\n\t */\r\n\tname = \"DirectoryError\";\r\n\r\n\t/**\r\n\t * Error code.\r\n\t * @type {string}\r\n\t */\r\n\tcode = \"EISDIR\";\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {string} message The error message.\r\n\t */\r\n\tconstructor(message) {\r\n\t\tsuper(`EISDIR: Illegal operation on a directory, ${message}`);\r\n\t}\r\n}\r\n\r\n/**\r\n * Error thrown when a directory is not empty.\r\n */\r\nexport class NotEmptyError extends Error {\r\n\t/**\r\n\t * Name of the error class.\r\n\t * @type {string}\r\n\t */\r\n\tname = \"NotEmptyError\";\r\n\r\n\t/**\r\n\t * Error code.\r\n\t * @type {string}\r\n\t */\r\n\tcode = \"ENOTEMPTY\";\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {string} message The error message.\r\n\t */\r\n\tconstructor(message) {\r\n\t\tsuper(`ENOTEMPTY: Directory not empty, ${message}`);\r\n\t}\r\n}\r\n", "/**\r\n * @fileoverview API entrypoint for hfs/core\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\nexport { Hfs } from \"./hfs.js\";\r\nexport { Path } from \"./path.js\";\r\nexport * from \"./errors.js\";\r\n", "// @ts-self-types=\"./retrier.d.ts\"\r\n/**\r\n * @fileoverview A utility for retrying failed async method calls.\r\n */\r\n\r\n/* global setTimeout, clearTimeout */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Constants\r\n//-----------------------------------------------------------------------------\r\n\r\nconst MAX_TASK_TIMEOUT = 60000;\r\nconst MAX_TASK_DELAY = 100;\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n/*\r\n * The following logic has been extracted from graceful-fs.\r\n *\r\n * The ISC License\r\n *\r\n * Copyright (c) 2011-2023 Isaac Z. Schlueter, Ben Noordhuis, and Contributors\r\n *\r\n * Permission to use, copy, modify, and/or distribute this software for any\r\n * purpose with or without fee is hereby granted, provided that the above\r\n * copyright notice and this permission notice appear in all copies.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\r\n * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r\n */\r\n\r\n/**\r\n * Checks if it is time to retry a task based on the timestamp and last attempt time.\r\n * @param {RetryTask} task The task to check.\r\n * @param {number} maxDelay The maximum delay for the queue.\r\n * @returns {boolean} true if it is time to retry, false otherwise.\r\n */\r\nfunction isTimeToRetry(task, maxDelay) {\r\n    const timeSinceLastAttempt = Date.now() - task.lastAttempt;\r\n    const timeSinceStart = Math.max(task.lastAttempt - task.timestamp, 1);\r\n    const desiredDelay = Math.min(timeSinceStart * 1.2, maxDelay);\r\n\r\n    return timeSinceLastAttempt >= desiredDelay;\r\n}\r\n\r\n/**\r\n * Checks if it is time to bail out based on the given timestamp.\r\n * @param {RetryTask} task The task to check.\r\n * @param {number} timeout The timeout for the queue.\r\n * @returns {boolean} true if it is time to bail, false otherwise.\r\n */\r\nfunction isTimeToBail(task, timeout) {\r\n    return task.age > timeout;\r\n}\r\n\r\n\r\n/**\r\n * A class to represent a task in the retry queue.\r\n */\r\nclass RetryTask {\r\n\r\n    /**\r\n     * The unique ID for the task.\r\n     * @type {string}\r\n     */\r\n    id = Math.random().toString(36).slice(2);\r\n\r\n    /**\r\n     * The function to call.\r\n     * @type {Function}\r\n     */\r\n    fn;\r\n\r\n    /**\r\n     * The error that was thrown.\r\n     * @type {Error}\r\n     */\r\n    error;\r\n    \r\n    /**\r\n     * The timestamp of the task.\r\n     * @type {number}\r\n     */\r\n    timestamp = Date.now();\r\n\r\n    /**\r\n     * The timestamp of the last attempt.\r\n     * @type {number}\r\n     */\r\n    lastAttempt = this.timestamp;\r\n\r\n    /**\r\n     * The resolve function for the promise.\r\n     * @type {Function}\r\n     */\r\n    resolve;\r\n\r\n    /**\r\n     * The reject function for the promise.\r\n     * @type {Function}\r\n     */\r\n    reject;\r\n\r\n    /**\r\n     * The AbortSignal to monitor for cancellation.\r\n     * @type {AbortSignal|undefined}\r\n     */\r\n    signal;\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     * @param {Function} fn The function to call.\r\n     * @param {Error} error The error that was thrown.\r\n     * @param {Function} resolve The resolve function for the promise.\r\n     * @param {Function} reject The reject function for the promise.\r\n     * @param {AbortSignal|undefined} signal The AbortSignal to monitor for cancellation.\r\n     */\r\n    constructor(fn, error, resolve, reject, signal) {\r\n        this.fn = fn;\r\n        this.error = error;\r\n        this.timestamp = Date.now();\r\n        this.lastAttempt = Date.now();\r\n        this.resolve = resolve;\r\n        this.reject = reject;\r\n        this.signal = signal;\r\n    }\r\n    \r\n    /**\r\n     * Gets the age of the task.\r\n     * @returns {number} The age of the task in milliseconds.\r\n     * @readonly\r\n     */\r\n    get age() {\r\n        return Date.now() - this.timestamp;\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Exports\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * A class that manages a queue of retry jobs.\r\n */\r\nclass Retrier {\r\n\r\n    /**\r\n     * Represents the queue for processing tasks.\r\n     * @type {Array<RetryTask>}\r\n     */\r\n    #queue = [];\r\n\r\n    /**\r\n     * The timeout for the queue.\r\n     * @type {number}\r\n     */\r\n    #timeout;\r\n\r\n    /**\r\n     * The maximum delay for the queue.\r\n     * @type {number}\r\n     */\r\n    #maxDelay;\r\n\r\n    /**\r\n     * The setTimeout() timer ID.\r\n     * @type {NodeJS.Timeout|undefined}\r\n     */\r\n    #timerId;\r\n\r\n    /**\r\n     * The function to call.\r\n     * @type {Function}\r\n     */\r\n    #check;\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     * @param {Function} check The function to call.\r\n     * @param {object} [options] The options for the instance.\r\n     * @param {number} [options.timeout] The timeout for the queue.\r\n     * @param {number} [options.maxDelay] The maximum delay for the queue.\r\n     */\r\n    constructor(check, { timeout = MAX_TASK_TIMEOUT, maxDelay = MAX_TASK_DELAY } = {}) {\r\n\r\n        if (typeof check !== \"function\") {\r\n            throw new Error(\"Missing function to check errors\");\r\n        }\r\n\r\n        this.#check = check;\r\n        this.#timeout = timeout;\r\n        this.#maxDelay = maxDelay;\r\n    }\r\n\r\n    /**\r\n     * Adds a new retry job to the queue.\r\n     * @param {Function} fn The function to call.\r\n     * @param {object} [options] The options for the job.\r\n     * @param {AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.\r\n     * @returns {Promise<any>} A promise that resolves when the queue is\r\n     *  processed.\r\n     */\r\n    retry(fn, { signal } = {}) {\r\n\r\n        signal?.throwIfAborted();\r\n\r\n        let result;\r\n\r\n        try {\r\n            result = fn();\r\n        } catch (/** @type {any} */ error) {\r\n            return Promise.reject(new Error(`Synchronous error: ${error.message}`, { cause: error }));\r\n        }\r\n\r\n        // if the result is not a promise then reject an error\r\n        if (!result || typeof result.then !== \"function\") {\r\n            return Promise.reject(new Error(\"Result is not a promise.\"));\r\n        }\r\n\r\n        // call the original function and catch any ENFILE or EMFILE errors\r\n        // @ts-ignore because we know it's any\r\n        return Promise.resolve(result).catch(error => {\r\n            if (!this.#check(error)) {\r\n                throw error;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                this.#queue.push(new RetryTask(fn, error, resolve, reject, signal));\r\n\r\n                signal?.addEventListener(\"abort\", () => {\r\n                    reject(signal.reason);\r\n                });\r\n\r\n                this.#processQueue();\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Processes the queue.\r\n     * @returns {void}\r\n     */\r\n    #processQueue() {\r\n        // clear any timer because we're going to check right now\r\n        clearTimeout(this.#timerId);\r\n        this.#timerId = undefined;\r\n\r\n        // if there's nothing in the queue, we're done\r\n        const task = this.#queue.shift();\r\n        if (!task) {\r\n            return;\r\n        }\r\n        const processAgain = () => {\r\n            this.#timerId = setTimeout(() => this.#processQueue(), 0);\r\n        };\r\n\r\n        // if it's time to bail, then bail\r\n        if (isTimeToBail(task, this.#timeout)) {\r\n            task.reject(task.error);\r\n            processAgain();\r\n            return;\r\n        }\r\n\r\n        // if it's not time to retry, then wait and try again\r\n        if (!isTimeToRetry(task, this.#maxDelay)) {\r\n            this.#queue.push(task);\r\n            processAgain();\r\n            return;\r\n        }\r\n\r\n        // otherwise, try again\r\n        task.lastAttempt = Date.now();\r\n        \r\n        // Promise.resolve needed in case it's a thenable but not a Promise\r\n        Promise.resolve(task.fn())\r\n            // @ts-ignore because we know it's any\r\n            .then(result => task.resolve(result))\r\n\r\n            // @ts-ignore because we know it's any\r\n            .catch(error => {\r\n                if (!this.#check(error)) {\r\n                    task.reject(error);\r\n                    return;\r\n                }\r\n\r\n                // update the task timestamp and push to back of queue to try again\r\n                task.lastAttempt = Date.now();\r\n                this.#queue.push(task);\r\n\r\n            })\r\n            .finally(() => this.#processQueue());\r\n    }\r\n}\r\n\r\nexport { Retrier };\r\n", "/**\r\n * @fileoverview The main file for the hfs package.\r\n * @author Nicholas C. Zakas\r\n */\r\n/* global Buffer:readonly, URL */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Types\r\n//-----------------------------------------------------------------------------\r\n\r\n/** @typedef {import(\"@humanfs/types\").HfsImpl} HfsImpl */\r\n/** @typedef {import(\"@humanfs/types\").HfsDirectoryEntry} HfsDirectoryEntry */\r\n/** @typedef {import(\"node:fs/promises\")} Fsp */\r\n/** @typedef {import(\"fs\").Dirent} Dirent */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Imports\r\n//-----------------------------------------------------------------------------\r\n\r\nimport { Hfs } from \"@humanfs/core\";\r\nimport path from \"node:path\";\r\nimport { Retrier } from \"@humanwhocodes/retry\";\r\nimport nativeFsp from \"node:fs/promises\";\r\nimport { fileURLToPath } from \"node:url\";\r\n\r\n//-----------------------------------------------------------------------------\r\n// Constants\r\n//-----------------------------------------------------------------------------\r\n\r\nconst RETRY_ERROR_CODES = new Set([\"ENFILE\", \"EMFILE\"]);\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * A class representing a directory entry.\r\n * @implements {HfsDirectoryEntry}\r\n */\r\nclass NodeHfsDirectoryEntry {\r\n\t/**\r\n\t * The name of the directory entry.\r\n\t * @type {string}\r\n\t */\r\n\tname;\r\n\r\n\t/**\r\n\t * True if the entry is a file.\r\n\t * @type {boolean}\r\n\t */\r\n\tisFile;\r\n\r\n\t/**\r\n\t * True if the entry is a directory.\r\n\t * @type {boolean}\r\n\t */\r\n\tisDirectory;\r\n\r\n\t/**\r\n\t * True if the entry is a symbolic link.\r\n\t * @type {boolean}\r\n\t */\r\n\tisSymlink;\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {Dirent} dirent The directory entry to wrap.\r\n\t */\r\n\tconstructor(dirent) {\r\n\t\tthis.name = dirent.name;\r\n\t\tthis.isFile = dirent.isFile();\r\n\t\tthis.isDirectory = dirent.isDirectory();\r\n\t\tthis.isSymlink = dirent.isSymbolicLink();\r\n\t}\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Exports\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * A class representing the Node.js implementation of Hfs.\r\n * @implements {HfsImpl}\r\n */\r\nexport class NodeHfsImpl {\r\n\t/**\r\n\t * The file system module to use.\r\n\t * @type {Fsp}\r\n\t */\r\n\t#fsp;\r\n\r\n\t/**\r\n\t * The retryer object used for retrying operations.\r\n\t * @type {Retrier}\r\n\t */\r\n\t#retrier;\r\n\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {object} [options] The options for the instance.\r\n\t * @param {Fsp} [options.fsp] The file system module to use.\r\n\t */\r\n\tconstructor({ fsp = nativeFsp } = {}) {\r\n\t\tthis.#fsp = fsp;\r\n\t\tthis.#retrier = new Retrier(error => RETRY_ERROR_CODES.has(error.code));\r\n\t}\r\n\r\n\t/**\r\n\t * Reads a file and returns the contents as an Uint8Array.\r\n\t * @param {string|URL} filePath The path to the file to read.\r\n\t * @returns {Promise<Uint8Array|undefined>} A promise that resolves with the contents\r\n\t *    of the file or undefined if the file doesn't exist.\r\n\t * @throws {Error} If the file cannot be read.\r\n\t * @throws {TypeError} If the file path is not a string.\r\n\t */\r\n\tbytes(filePath) {\r\n\t\treturn this.#retrier\r\n\t\t\t.retry(() => this.#fsp.readFile(filePath))\r\n\t\t\t.then(buffer => new Uint8Array(buffer.buffer))\r\n\t\t\t.catch(error => {\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Writes a value to a file. If the value is a string, UTF-8 encoding is used.\r\n\t * @param {string|URL} filePath The path to the file to write.\r\n\t * @param {Uint8Array} contents The contents to write to the\r\n\t *   file.\r\n\t * @returns {Promise<void>} A promise that resolves when the file is\r\n\t *  written.\r\n\t * @throws {TypeError} If the file path is not a string.\r\n\t * @throws {Error} If the file cannot be written.\r\n\t */\r\n\tasync write(filePath, contents) {\r\n\t\tconst value = Buffer.from(contents);\r\n\r\n\t\treturn this.#retrier\r\n\t\t\t.retry(() => this.#fsp.writeFile(filePath, value))\r\n\t\t\t.catch(error => {\r\n\t\t\t\t// the directory may not exist, so create it\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\tconst dirPath = path.dirname(\r\n\t\t\t\t\t\tfilePath instanceof URL\r\n\t\t\t\t\t\t\t? fileURLToPath(filePath)\r\n\t\t\t\t\t\t\t: filePath,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\treturn this.#fsp\r\n\t\t\t\t\t\t.mkdir(dirPath, { recursive: true })\r\n\t\t\t\t\t\t.then(() => this.#fsp.writeFile(filePath, value));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Appends a value to a file. If the value is a string, UTF-8 encoding is used.\r\n\t * @param {string|URL} filePath The path to the file to append to.\r\n\t * @param {Uint8Array} contents The contents to append to the\r\n\t *  file.\r\n\t * @returns {Promise<void>} A promise that resolves when the file is\r\n\t * written.\r\n\t * @throws {TypeError} If the file path is not a string.\r\n\t * @throws {Error} If the file cannot be appended to.\r\n\t */\r\n\tasync append(filePath, contents) {\r\n\t\tconst value = Buffer.from(contents);\r\n\r\n\t\treturn this.#retrier\r\n\t\t\t.retry(() => this.#fsp.appendFile(filePath, value))\r\n\t\t\t.catch(error => {\r\n\t\t\t\t// the directory may not exist, so create it\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\tconst dirPath = path.dirname(\r\n\t\t\t\t\t\tfilePath instanceof URL\r\n\t\t\t\t\t\t\t? fileURLToPath(filePath)\r\n\t\t\t\t\t\t\t: filePath,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\treturn this.#fsp\r\n\t\t\t\t\t\t.mkdir(dirPath, { recursive: true })\r\n\t\t\t\t\t\t.then(() => this.#fsp.appendFile(filePath, value));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if a file exists.\r\n\t * @param {string|URL} filePath The path to the file to check.\r\n\t * @returns {Promise<boolean>} A promise that resolves with true if the\r\n\t *    file exists or false if it does not.\r\n\t * @throws {Error} If the operation fails with a code other than ENOENT.\r\n\t */\r\n\tisFile(filePath) {\r\n\t\treturn this.#fsp\r\n\t\t\t.stat(filePath)\r\n\t\t\t.then(stat => stat.isFile())\r\n\t\t\t.catch(error => {\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if a directory exists.\r\n\t * @param {string|URL} dirPath The path to the directory to check.\r\n\t * @returns {Promise<boolean>} A promise that resolves with true if the\r\n\t *    directory exists or false if it does not.\r\n\t * @throws {Error} If the operation fails with a code other than ENOENT.\r\n\t */\r\n\tisDirectory(dirPath) {\r\n\t\treturn this.#fsp\r\n\t\t\t.stat(dirPath)\r\n\t\t\t.then(stat => stat.isDirectory())\r\n\t\t\t.catch(error => {\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a directory recursively.\r\n\t * @param {string|URL} dirPath The path to the directory to create.\r\n\t * @returns {Promise<void>} A promise that resolves when the directory is\r\n\t *   created.\r\n\t */\r\n\tasync createDirectory(dirPath) {\r\n\t\tawait this.#fsp.mkdir(dirPath, { recursive: true });\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes a file or empty directory.\r\n\t * @param {string|URL} fileOrDirPath The path to the file or directory to\r\n\t *   delete.\r\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\r\n\t *   directory is deleted, true if the file or directory is deleted, false\r\n\t *   if the file or directory does not exist.\r\n\t * @throws {TypeError} If the file or directory path is not a string.\r\n\t * @throws {Error} If the file or directory cannot be deleted.\r\n\t */\r\n\tdelete(fileOrDirPath) {\r\n\t\treturn this.#fsp\r\n\t\t\t.rm(fileOrDirPath)\r\n\t\t\t.then(() => true)\r\n\t\t\t.catch(error => {\r\n\t\t\t\tif (error.code === \"ERR_FS_EISDIR\") {\r\n\t\t\t\t\treturn this.#fsp.rmdir(fileOrDirPath).then(() => true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes a file or directory recursively.\r\n\t * @param {string|URL} fileOrDirPath The path to the file or directory to\r\n\t *   delete.\r\n\t * @returns {Promise<boolean>} A promise that resolves when the file or\r\n\t *   directory is deleted, true if the file or directory is deleted, false\r\n\t *   if the file or directory does not exist.\r\n\t * @throws {TypeError} If the file or directory path is not a string.\r\n\t * @throws {Error} If the file or directory cannot be deleted.\r\n\t */\r\n\tdeleteAll(fileOrDirPath) {\r\n\t\treturn this.#fsp\r\n\t\t\t.rm(fileOrDirPath, { recursive: true })\r\n\t\t\t.then(() => true)\r\n\t\t\t.catch(error => {\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of directory entries for the given path.\r\n\t * @param {string|URL} dirPath The path to the directory to read.\r\n\t * @returns {AsyncIterable<HfsDirectoryEntry>} A promise that resolves with the\r\n\t *   directory entries.\r\n\t * @throws {TypeError} If the directory path is not a string.\r\n\t * @throws {Error} If the directory cannot be read.\r\n\t */\r\n\tasync *list(dirPath) {\r\n\t\tconst entries = await this.#fsp.readdir(dirPath, {\r\n\t\t\twithFileTypes: true,\r\n\t\t});\r\n\r\n\t\tfor (const entry of entries) {\r\n\t\t\tyield new NodeHfsDirectoryEntry(entry);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the size of a file. This method handles ENOENT errors\r\n\t * and returns undefined in that case.\r\n\t * @param {string|URL} filePath The path to the file to read.\r\n\t * @returns {Promise<number|undefined>} A promise that resolves with the size of the\r\n\t *  file in bytes or undefined if the file doesn't exist.\r\n\t */\r\n\tsize(filePath) {\r\n\t\treturn this.#fsp\r\n\t\t\t.stat(filePath)\r\n\t\t\t.then(stat => stat.size)\r\n\t\t\t.catch(error => {\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the last modified date of a file or directory. This method handles ENOENT errors\r\n\t * and returns undefined in that case.\r\n\t * @param {string|URL} fileOrDirPath The path to the file to read.\r\n\t * @returns {Promise<Date|undefined>} A promise that resolves with the last modified\r\n\t * date of the file or directory, or undefined if the file doesn't exist.\r\n\t */\r\n\tlastModified(fileOrDirPath) {\r\n\t\treturn this.#fsp\r\n\t\t\t.stat(fileOrDirPath)\r\n\t\t\t.then(stat => stat.mtime)\r\n\t\t\t.catch(error => {\r\n\t\t\t\tif (error.code === \"ENOENT\") {\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Copies a file from one location to another.\r\n\t * @param {string|URL} source The path to the file to copy.\r\n\t * @param {string|URL} destination The path to copy the file to.\r\n\t * @returns {Promise<void>} A promise that resolves when the file is copied.\r\n\t * @throws {Error} If the source file does not exist.\r\n\t * @throws {Error} If the source file is a directory.\r\n\t * @throws {Error} If the destination file is a directory.\r\n\t */\r\n\tcopy(source, destination) {\r\n\t\treturn this.#fsp.copyFile(source, destination);\r\n\t}\r\n\r\n\t/**\r\n\t * Copies a file or directory from one location to another.\r\n\t * @param {string|URL} source The path to the file or directory to copy.\r\n\t * @param {string|URL} destination The path to copy the file or directory to.\r\n\t * @returns {Promise<void>} A promise that resolves when the file or directory is\r\n\t * copied.\r\n\t * @throws {Error} If the source file or directory does not exist.\r\n\t * @throws {Error} If the destination file or directory is a directory.\r\n\t */\r\n\tasync copyAll(source, destination) {\r\n\t\t// for files use copy() and exit\r\n\t\tif (await this.isFile(source)) {\r\n\t\t\treturn this.copy(source, destination);\r\n\t\t}\r\n\r\n\t\tconst sourceStr =\r\n\t\t\tsource instanceof URL ? fileURLToPath(source) : source;\r\n\r\n\t\tconst destinationStr =\r\n\t\t\tdestination instanceof URL\r\n\t\t\t\t? fileURLToPath(destination)\r\n\t\t\t\t: destination;\r\n\r\n\t\t// for directories, create the destination directory and copy each entry\r\n\t\tawait this.createDirectory(destination);\r\n\r\n\t\tfor await (const entry of this.list(source)) {\r\n\t\t\tconst fromEntryPath = path.join(sourceStr, entry.name);\r\n\t\t\tconst toEntryPath = path.join(destinationStr, entry.name);\r\n\r\n\t\t\tif (entry.isDirectory) {\r\n\t\t\t\tawait this.copyAll(fromEntryPath, toEntryPath);\r\n\t\t\t} else {\r\n\t\t\t\tawait this.copy(fromEntryPath, toEntryPath);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Moves a file from the source path to the destination path.\r\n\t * @param {string|URL} source The location of the file to move.\r\n\t * @param {string|URL} destination The destination of the file to move.\r\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\r\n\t * @throws {TypeError} If the file paths are not strings.\r\n\t * @throws {Error} If the file cannot be moved.\r\n\t */\r\n\tmove(source, destination) {\r\n\t\treturn this.#fsp.stat(source).then(stat => {\r\n\t\t\tif (stat.isDirectory()) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t`EISDIR: illegal operation on a directory, move '${source}' -> '${destination}'`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\treturn this.#fsp.rename(source, destination);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Moves a file or directory from the source path to the destination path.\r\n\t * @param {string|URL} source The location of the file or directory to move.\r\n\t * @param {string|URL} destination The destination of the file or directory to move.\r\n\t * @returns {Promise<void>} A promise that resolves when the move is complete.\r\n\t * @throws {TypeError} If the file paths are not strings.\r\n\t * @throws {Error} If the file or directory cannot be moved.\r\n\t */\r\n\tasync moveAll(source, destination) {\r\n\t\treturn this.#fsp.rename(source, destination);\r\n\t}\r\n}\r\n\r\n/**\r\n * A class representing a file system utility library.\r\n * @implements {HfsImpl}\r\n */\r\nexport class NodeHfs extends Hfs {\r\n\t/**\r\n\t * Creates a new instance.\r\n\t * @param {object} [options] The options for the instance.\r\n\t * @param {Fsp} [options.fsp] The file system module to use.\r\n\t */\r\n\tconstructor({ fsp } = {}) {\r\n\t\tsuper({ impl: new NodeHfsImpl({ fsp }) });\r\n\t}\r\n}\r\n\r\nexport const hfs = new NodeHfs();\r\n", "/**\r\n * @fileoverview This file exports everything for this package.\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\nexport * from \"./node-hfs.js\";\r\nexport { Hfs } from \"@humanfs/core\";\r\n"],
  "mappings": "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",
  "names": ["dirPath", "directoryFilter", "entryFilter", "nativeFsp", "path", "init_src"]
}
